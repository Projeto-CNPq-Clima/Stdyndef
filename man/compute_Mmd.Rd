% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compute_Mmd.R
\name{compute_Mmd}
\alias{compute_Mmd}
\title{Computes the Mmd matrix using Spatial Deformation MCMC output}
\usage{
compute_Mmd(MCMC_output, response, sites, Map, dd)
}
\arguments{
\item{MCMC_output}{A list containing the output of \code{SpatialDeformationMCMC}, which includes the matrix \code{MDef}.}

\item{response}{A matrix of observed values for the response variable.}

\item{sites}{A matrix containing the geographic coordinates of the locations.}

\item{Map}{A matrix representing the geographic coordinates of the map boundaries.}

\item{dd}{An integer specifying the resolution of the grid, where the estimated deformations will be
computed for a grid of dimension \verb{(dd+1) x (dd+1)}.}
}
\value{
A matrix where each column represents the posterior estimate of the q-th dynamic deformation
on a grid of dimension \verb{(dd+1) x (dd+1)}. Additionally, it includes the \code{Map} outline as a reference
for spatial context.
}
\description{
Computes the Mmd matrix using Spatial Deformation MCMC output
}
\details{
This function calculates the dynamic deformations by using posterior samples obtained from MCMC estimation.
For each posterior sample, the deformations are interpolated over a specified grid resolution \verb{(dd+1) x (dd+1)},
with each column in the resulting matrix corresponding to the posterior deformation estimates at that grid
resolution. The \code{Map} outline is returned alongside these estimates for geographic reference.
}
\examples{
# Load necessary data and libraries
library(Stdyndef)
library(MASS)
data(temperature)
data(FT)
data(MatFFT)
data(GT)
data(sites)
data(GAMA)
data(Map)

# Run MCMC to obtain posterior estimates
Mod <- SpatialDeformationMCMC(
  response = temperature,
  FT = FT,
  MatFFT = MatFFT,
  GT = GT,
  sites = sites,
  GAMA = GAMA,
  iteration = 100,
  burnin = 50,
  jump = 1
)

# Compute the posterior deformations on a 10x10 grid
DDj <- compute_Mmd(Mod, temperature, sites, Map, dd = 10)

# Select deformation for the first year in the series
j <- 1  # (j = 1, 2, ..., 15 for each posterior estimate over time)
year <- 2007:2021
xd <- DDj[1:(nrow(DDj) / 2), j]
yd <- DDj[(nrow(DDj) / 2 + 1):nrow(DDj), j]

# Combine x and y coordinates for grid and map deformations
xyd <- cbind(xd, yd)
xydgrad <- xyd[1:121, 1:2]
xydMap <- xyd[122:(121 + nrow(Map)), 1:2]

# Plot the deformation grid and map outline
plot(xydMap, type = "l", xlab = "Longitude", ylab = "Latitude", main = paste("Year:", year[j]), lty = 1)

# Define grid lines
dd <- 10
lse1 <- seq(1, (dd + 1)^2, by = (dd + 1))
lse2 <- seq((dd + 1), (dd + 1)^2, by = (dd + 1))
minix <- min(xydgrad[, 1])
maxix <- max(xydgrad[, 1])
miniy <- min(xydgrad[, 2])
maxiy <- max(xydgrad[, 2])

# Overlay the grid lines on the deformation map
for (i in 1:(dd + 1)) {
  plot(xydgrad[(lse1[i]):(lse2[i]), 1:2], type = "l", lty = 2, xlab = "", ylab = "",
       xlim = c(minix, maxix), ylim = c(miniy, maxiy), add = TRUE)
  plot(xydgrad[seq(i, (dd + 1)^2, by = (dd + 1)), 1:2], type = "l", lty = 2, xlab = "", ylab = "",
       xlim = c(minix, maxix), ylim = c(miniy, maxiy), add = TRUE)
}

# Finalize the plot with map outline
plot(xydMap, type = "l", xlab = "", ylab = "", xlim = c(minix, maxix), ylim = c(miniy, maxiy),
     main = paste("Year:", year[j]), lty = 1)

}
